#define EIGEN_DONT_PARALLELIZE
#define __STDC_LIMIT_MACROS
#include <stdint.h>
#include <iostream>
#include <queue>
#include <random>
#include <iomanip>
#include "marvin.hpp"
#include "EM.hpp"
#include <time.h>  
#include <limits>      
#include <Eigen/Eigenvalues> 

#include "htslib/hts.h"

using namespace std;
using namespace Eigen;


extern "C" {
#include "htslib/synced_bcf_reader.h"
}

void usage(){
  cerr << "Imputation from GLs" << endl;
  cerr << "Usage:" << endl;
  cerr << "./marvin -f input.vcf" << endl;
  cerr << "Expects input.vcf to contain GLs/PLs." << endl;
  cerr << "\n\t  Input params...\n" << endl;
  cerr << "\t -f  : 		input vcf" << endl;
  cerr << "\t -o  : 		output vcf" << endl;
  cerr << "\t -O  : 		output vcf type" << endl;
  cerr << "\t -Ogp:			output genotype probabilities" << endl;
  cerr << "\t -r: 			chromosome region (default all)" << endl;
  cerr << "\t -b: 			overlap on both sides (default 0)" << endl;
  cerr << "\t -num_threads: 	threads in a single window (default 1)" << endl;
  cerr << "\n\t  Panel params...\n" << endl;
  cerr << "\t -fm: 		allele frequencies generated by marvin_prep" << endl;
  cerr << "\t -fw: 		MVN update matrix generated by marvin_prep" << endl;
  cerr << "\t -fv: 		MVN variances generated by marvin_prep" << endl;
  cerr << "\t -site:	vcf with sites in panel" << endl;
  cerr << "\t -zm:		zero missing rows (assumes 0/0)" << endl;
  cerr << "\t -c:		collapse snps|indels|both|all|some|none" << endl;
  cerr << "\n\t  Run params...\n" << endl;
  cerr << "\t -max_its: 	number of iterations of algorithm (default 2)" << endl;
  cerr << "\t -inner_its:	number of iterations of inner loop (updating means, default 1)" << endl;
  cerr << "\t -EMits:		number of iterations for EM initialization" << endl;
  cerr << "\t -maxlr: 		max likelihood ratio" << endl;
  cerr << "\t -bias:		dosage < bias gt = 0, dosage > 2-bias gt = 2; (default 0.5)" << endl;
  cerr << "\n\t  Run params...\n" << endl;
  cerr << "\t -sigma_reg: 	use sigma regularization with params lambda, lambda2, pct" << endl;
  cerr << "\t -lambda: 		regularization parameter (0.06)" << endl;
  cerr << "\t -lambda2:		threshold steepness (4)" << endl;
  cerr << "\t -pct:			sig mid point (0.2)" << endl;

  exit(1);
	
}

int main(int argc, char* argv[])
{	
	
  //input vcf
  if( !cmdOptionExists(argv, argv+argc, "-f" ) ){ usage(); }
  char* filename = getCmdOption(argv, argv+argc, "-f" );
	
  //Read in fixed reference panel data
  bool use_panel = false;
  string pfilename;
  string mfilename = "mu.dat";
  string wfilename = "omega.dat"; 
  string vfilename = "var.dat"; 

  if( cmdOptionExists(argv, argv+argc, "-fm" ) ){ use_panel=true; mfilename = getCmdOption(argv, argv+argc, "-fm" ); }
  if( cmdOptionExists(argv, argv+argc, "-fw" ) ){ use_panel=true; wfilename = getCmdOption(argv, argv+argc,  "-fw" ); }
  if( cmdOptionExists(argv, argv+argc, "-fv" ) ){ use_panel=true; vfilename = getCmdOption(argv, argv+argc,  "-fv" ); }
  if( use_panel 
      && !(
	   cmdOptionExists(argv, argv+argc, "-fm" ) && 
	   cmdOptionExists(argv, argv+argc, "-fw" ) && cmdOptionExists(argv, argv+argc, "-fv" )
	   ) ){ 
    cerr << "Enter all 3 binary files from marvin_prep" << endl; usage();
  }
	
  if( use_panel ){
    if( cmdOptionExists(argv, argv+argc, "-site" ) ){ 
      pfilename = getCmdOption(argv, argv+argc, "-site" ); 
    } else {
      cerr << "Input site file name with -site" << endl; usage();
    }	
  }
  bool zero_missing = cmdOptionExists(argv, argv+argc, "-zm" );

  //output vcf
  string out_filename = "out.vcf";
  if( cmdOptionExists(argv, argv+argc, "-o" ) ){ out_filename = getCmdOption(argv, argv+argc, "-o" ); } 
  string out_type = "w";
  if( cmdOptionExists(argv, argv+argc, "-O" ) ){ 
    out_type += (string)( getCmdOption(argv, argv+argc, "-O" ) );
  } 
  bool glout = cmdOptionExists(argv, argv+argc, "-Ogp" );
	
  //overlap
  int B = 0;
  int minpos = 0;
  int maxpos = std::numeric_limits<int>::max(); 
  if( cmdOptionExists(argv, argv+argc, "-b" ) ){ B = atoi( getCmdOption(argv, argv+argc, "-b" ) ); }
	
  //subsetting
  string regions;
  string use_regions;
  bool get_regions = cmdOptionExists(argv, argv+argc, "-r" );
  if(get_regions){ 
    regions = getCmdOption(argv, argv+argc, "-r" );
    use_regions = regions;
    if(B>0){
      stringstream ss(regions);
      string chr, item;
      getline(ss, chr, ':'); getline(ss, item, ':');

      stringstream ss2(item);
      string left, right;
      getline(ss2, left, '-'); getline(ss2, right, '-');
			
      minpos = stoi(left) -1;
      maxpos = stoi(right)-1;
      use_regions = chr + ":" + to_string( max(0, stoi(left) - B) ) + "-" + to_string( stoi(right) + B );
      cerr << "Using region " << use_regions << ", overlap " << B << ", outputting " << regions << endl;
    }
  }
	
  //regularization
  float lambda = 0.06;
  if( cmdOptionExists(argv, argv+argc, "-lambda" ) ){ lambda = atof(getCmdOption(argv, argv+argc, "-lambda" )); }
  float lambda2 = 4;
  if( cmdOptionExists(argv, argv+argc, "-lambda2" ) ){ lambda2 = atof(getCmdOption(argv, argv+argc, "-lambda2" )); }
  float pct = 0.2;
  if( cmdOptionExists(argv, argv+argc, "-pct" ) ){ pct = atof(getCmdOption(argv, argv+argc, "-pct" )); }
  bool sigma_reg = cmdOptionExists(argv, argv+argc, "-sigma_reg" );

  //number of iterations
  int max_its = 5;
  if( cmdOptionExists(argv, argv+argc, "-max_its" ) ){
    max_its = atoi( getCmdOption(argv, argv+argc, "-max_its" ) );
  }

  //maximum liklihood ratio
  float maxlr = -100;
  if( cmdOptionExists(argv, argv+argc, "-maxlr" ) ){
    maxlr = atof( getCmdOption(argv, argv+argc, "-maxlr" ) );
  }

  //How to interpret evidence from probabilities
  float bias = 0.5;
  if( cmdOptionExists(argv, argv+argc, "-bias" ) ){
    bias = atof( getCmdOption(argv, argv+argc, "-bias" ) );
  }
				
  //How many inner iterations of algorithm
  int inner_its = 1;
  if( cmdOptionExists(argv, argv+argc, "-inner_its" ) ){
    inner_its = atoi( getCmdOption(argv, argv+argc, "-inner_its" ) );
  }

  //How many steps of EM to start, too many can lose some information
  int EMits = 1;
  if( cmdOptionExists(argv, argv+argc, "-EMits" ) ){
    EMits = atoi( getCmdOption(argv, argv+argc, "-EMits" ) );
  }	

  //number of threads
  int num_threads = 1;
  if( cmdOptionExists(argv, argv+argc, "-num_threads" ) ){
    num_threads = atoi( getCmdOption(argv, argv+argc, "-num_threads" ) );
  }	
		
  //No parallelism, use cores for different windows
  //Eigen::initParallel();
  //setNbThreads(0);

  omp_set_num_threads(num_threads);
  #pragma omp parallel
  {
    if(omp_get_thread_num() == 0){
      if( omp_get_num_threads() != 1){
	cerr << "there are " << omp_get_num_threads() << " threads" << endl;
	cerr << "parallelism gives only small speed up here, use extra cores for other windows" << endl;
      }
    }
  }
  
	int collapse = COLLAPSE_NONE;
	if( cmdOptionExists(argv, argv+argc, "-c" ) ){ 
		string ctype = (string)( getCmdOption(argv, argv+argc, "-c" ) );
		if( ctype == "none"){
			collapse = COLLAPSE_NONE; cerr << "collapse none" << endl;
		} else if (ctype == "snps") {
			collapse = COLLAPSE_SNPS; cerr << "collapse snps" << endl;
		} else if (ctype == "indels") {
			collapse = COLLAPSE_INDELS; cerr << "collapse indels" << endl;
		} else if (ctype == "any") {
			collapse = COLLAPSE_ANY; cerr << "collapse any" << endl;
		} else if (ctype == "some") {
			collapse = COLLAPSE_SOME; cerr << "collapse some" << endl;
		} else if (ctype == "both") {
			collapse = COLLAPSE_BOTH; cerr << "collapse both" << endl;
		} else {
			collapse = COLLAPSE_NONE; cerr << "collapse none" << endl;
		}
	} 
		
  //input reader set up
  bcf_srs_t *sr =  bcf_sr_init() ; ///htslib synced reader.
  sr->collapse = collapse;
	
  if(get_regions){
    sr->require_index = 1;
    if ( bcf_sr_set_regions(sr, use_regions.c_str(), false)<0 ){
      cerr << "Failed to read the regions: " <<  use_regions << endl; exit(1);
    }
  }
	
  sr->require_index = 1;
  if(!(bcf_sr_add_reader (sr, filename ))){ 
    cerr << "Problem opening " << filename << endl; 
    bcf_sr_destroy(sr);	
    return 0;
  }
  if(use_panel){if(!(bcf_sr_add_reader (sr, pfilename.c_str() ))){ 
      cerr << "Problem opening " << pfilename << endl; 
      bcf_sr_destroy(sr);	
      return 0;
  }}
	
  int N = bcf_hdr_nsamples(sr->readers[0].header);	///number of samples
  float nm = 1.0/N; 
  float snm = sqrt(nm);
  int ngl = N*3;
  int ngl_arr = N*3;
  cerr << N << " samples in " << filename << endl;
	
  bcf1_t *line, *line2;///bcf/vcf line structure.
  vector< float* > gl;
  int M=0;
	
  vector<int> sites_to_skip;	//sites in panel but not sample
  int panel_uniq=0;
  int sample_number=0;
  int sample_uniq=0;
  int sample_ma=0;
  int common_var=0;
	
  int min_idx = 0;
  int max_idx = 0;
  
  //this goes before the while loop starts
  int32_t *PL;//stores the phred scaled likelihoods (if needed)
  int *GT = new int[N*2];

  //float GL is built on the fly per line.
  if ( bcf_hdr_id2int(sr->readers[0].header, BCF_DT_ID, "PL")!=-1 ){
	PL = new int32_t[N*3];
  } else if ( bcf_hdr_id2int(sr->readers[0].header, BCF_DT_ID, "GL")<0 ) {
    cerr << "ERROR: neither FORMAT/GL nor FORMAT/PL were defined!"<<endl;
    exit(1);
  }    
  
  while(bcf_sr_next_line (sr)) { 
    bool count = true;
    
    if( use_panel ){ count = (bcf_sr_has_line(sr,0) && bcf_sr_has_line(sr,1)); }
    if( count ){
      //if using panel, in panel and sample
      line =  bcf_sr_get_line(sr, 0);
      bool read = ( line->n_allele == 2 );
      if( use_panel && line->n_allele != 2 ){	//multiallelic in sample but not panel
		line2 = bcf_sr_get_line(sr, 1);
		read = ( line2->n_allele == 2 );
		++sample_ma;
      }
      if( read ){
		if(B>0 && !use_panel){
			if(line->pos < minpos){ ++min_idx; }
			if(line->pos < maxpos){ ++max_idx; }
		}
		
		///reads GLs (or PLs if there are no GLs (or GTs if there are no PLs) )
		float *gl_farr= new float[N*3];//new set of GLs that will get pushed into vector.
		ngl = bcf_get_format_float(sr->readers[0].header, line, "GL", &gl_farr, &ngl_arr); 
		
		if(ngl<0) {//-1 or -3 FORMAT/GL is missing.

			if(ngl==-2) {
				cerr<<"FORMAT/GL had bad type at "<< line->pos+1<<" "<<ngl<<endl;
				exit(1);
			}
			ngl = bcf_get_format_int32(sr->readers[0].header, line, "PL", &PL, &ngl_arr);        
			if(ngl==-2) {
				cerr<<"FORMAT/PL had bad type at "<< line->pos+1<<" "<<ngl<<endl;
				exit(1);
			} else if(ngl<0) {
				if(bcf_get_genotypes(sr->readers[0].header, line, &GT, &ngl_arr)==2*N) {
					cerr << "WARNING: no genotype likelihoods available at "<< line->pos+1<<" (deriving from GT) "<<endl;

					for(int i=0; i<N; ++i) {
						for(int j=0;j<3;j++){ gl_farr[i*3+j] = -1000; }
						if(GT[i*2]!=bcf_gt_missing&&GT[i*2+1]!=bcf_gt_missing) {
							int g = bcf_gt_allele(GT[i*2])+bcf_gt_allele(GT[i*2+1]);
							gl_farr[i*3 + g] = 0.0;
						}
					}       
				} else {//flat likelihood.
					cerr << "WARNING: no genotype likelihoods or GT available at "<< line->pos+1<<" (flat GL assigned) "<<endl;
					for(int i=0; i<3*N; ++i) gl_farr[i] = 0.0;
				}
			}
			else {
				for(int i=0; i<3*N; ++i) gl_farr[i] = (float)(-0.1 * PL[i]);
			}
		}
		
		gl.push_back( gl_farr );

		++common_var;
		if( !use_panel ) ++M;
	} 		
    } 
    if( use_panel ){ 
			
		if( bcf_sr_has_line(sr,1) ){	//in panel
			if( !bcf_sr_has_line(sr,0) ){	//not in sample or missing
				sites_to_skip.push_back(M); //skip these?
				float *gl_farr= new float[N*3];
				for(int i=0; i<3*N; ++i){ gl_farr[i] = (float)1; }
				gl.push_back( gl_farr ); 
				++panel_uniq;
			} 
			if(B>0){
				line =  bcf_sr_get_line(sr, 1);
				if(line->pos < minpos){ ++min_idx; }
				if(line->pos < maxpos){ ++max_idx; }
			}
			++M; 
		} 
		if( bcf_sr_has_line(sr,0) ){ //in sample
			++sample_number; 
			if( !bcf_sr_has_line(sr,1) ){ //not in panel
				++sample_uniq;
			}
		} 
    }
	}

  cerr << "processing " << gl.size() << " variants on " << N << " individuals" << endl; 
  if( use_panel ){ 
    cerr << M << "\tin panel" << endl;
    cerr << sample_number 	<< "\tin sample" << endl;
    cerr << common_var 		<< "\tcommon"  << endl;
    cerr << sample_ma 		<< "\tmulti-allelic sample sites biallelic in panel" << endl;
    cerr << panel_uniq 		<< "\tuniq to panel" << endl;
    cerr << sample_uniq 	<< "\tuniq to sample" << endl;
    if( zero_missing ){ cerr << "\t Zeroing " << sites_to_skip.size() << " sites" << endl; }
    if( sample_ma ){ cerr << "Taking AF for first variant, you should normalise indels with vt" << endl; }
    if( panel_uniq != 0 || sample_uniq != 0){ cerr << "Impute at intersection of sample and panel" << endl; }
  } 
  if(M != gl.size()){ cerr << "count error" << endl; exit(1); }
  if(B<=0){ min_idx = 0; max_idx = M; }
  else{ cerr << "Output variants " << min_idx << " to " << max_idx << endl; }
	
  bcf_sr_destroy(sr);	

  
	//GLs to GPs
	float norm;
	int sidx = 0;
	for(int i=0; i<M; ++i){
		for(int j=0; j<N; ++j){
			
			int j0 = 3*j;
			int j1 = j0+1;
			int j2 = j1+1;

			gl[i][j0] = pow(10,gl[i][j0]);
			gl[i][j1] = pow(10,gl[i][j1]);
			gl[i][j2] = pow(10,gl[i][j2]);

			norm = gl[i][j0]+gl[i][j1]+gl[i][j2];
			if( norm != 0 ){
				gl[i][j0] /= norm;
				gl[i][j1] /= norm;
				gl[i][j2] /= norm;
			} 
						
			if( maxlr > 0 ){
				float maxl = gl[i][j0]; 
				if(gl[i][j1] > maxl){ maxl = gl[i][j1]; }
				if(gl[i][j2] > maxl){ maxl = gl[i][j2]; }
					
				gl[i][j0] = (maxl > maxlr*gl[i][j0]) ? maxl/maxlr : gl[i][j0]; 
				gl[i][j1] = (maxl > maxlr*gl[i][j1]) ? maxl/maxlr : gl[i][j1];
				gl[i][j2] = (maxl > maxlr*gl[i][j2]) ? maxl/maxlr : gl[i][j2];
				
				norm = gl[i][j0]+gl[i][j1]+gl[i][j2];
			
				gl[i][j0] /= norm;
				gl[i][j1] /= norm;
				gl[i][j2] /= norm;
			} 

			if(zero_missing &&  sidx < sites_to_skip.size() && i==sites_to_skip[sidx] ){ 
				gl[i][j0] = 0;
				gl[i][j1] = 0;
				gl[i][j2] = 0;
				++sidx;
			}
		}
	} 
	
	MatrixXf D(M, N);
	
	if(use_panel){ max_its = 1; } else { EMexpectation(gl, D, EMits); }
	
	VectorXf mu(M);
	MatrixXf Sigma(M, M);
	MatrixXf lv(M,M);
	VectorXf sigs(M);
	MatrixXf Probs;
	
	for(int its = 0; its<max_its; ++its){

		if( use_panel ){
			
			cerr << "Reading and resizing panel params" << endl;

			ifstream inm(mfilename.c_str(), ios::binary);
			inm.read((char *)mu.data(), sizeof(typename VectorXf::Scalar)*M);
			if (inm.bad()){ cerr << "Read fm error" << endl; exit(1); }
			inm.close();
			
			ifstream inw(wfilename.c_str(), ios::binary);
			inw.read((char *)lv.data(), sizeof(typename MatrixXf::Scalar)*M*M);
			if (inw.bad()){ cerr << "Read fw error" << endl; exit(1); }
			inw.close();

			ifstream inv(vfilename.c_str(), ios::binary);
			inv.read((char *)sigs.data(), sizeof(typename VectorXf::Scalar)*M);
			if (inv.bad()){ cerr << "Read fv error" << endl; exit(1); }
			inv.close();

			//bad guess
			prob_from_af(gl, mu, D);

			//if N > 2M zero the panel
			if( zero_missing ){
			for(int i=0; i<sites_to_skip.size(); ++i){ 
				D.row( sites_to_skip[i] ) = VectorXf::Zero(N); 
				mu(  sites_to_skip[i] ) = 0;
				sigs(  sites_to_skip[i] ) = 0;
				lv.row( sites_to_skip[i] ) = VectorXf::Zero(N); 
				lv.col( sites_to_skip[i] ) = VectorXf::Zero(N); 
			}} 
			
		} else {
			
			for(int i=0; i<M; ++i){ mu(i) = D.row(i).sum()*nm; }
			cerr << "calculating Sigma for iteration " << its << endl;				
			Sigma = D*D.transpose()*nm - mu*mu.transpose();

			for(int i=0; i<M;++i){ 
				if( sigma_reg ){
					Sigma(i,i) += lambda / (1.0 + exp( lambda2 * ( Sigma(i,i) - pct ) ) );
				} else {
					Sigma(i,i) += lambda;
				}
			}
		
		}
		
		MVNiterate(Sigma, mu, lv, sigs, !use_panel, inner_its, gl, D);
							
	}//end its 



  cerr <<"Printing genotypes to " << out_filename << endl; 
  bcf_srs_t *reader = bcf_sr_init();
  reader->collapse = collapse;

  if(get_regions){
    reader->require_index = 1;
    if ( bcf_sr_set_regions(reader, use_regions.c_str(), false)<0 ){
      cerr << "Failed to read the regions: " << use_regions << endl; exit(1);
    }
  }

  reader->require_index = 1;
  if(!(bcf_sr_add_reader (reader, filename ))){ cerr << "Problem opening " << filename << endl; exit(1); }
  if(use_panel){
    if(!(bcf_sr_add_reader (reader, pfilename.c_str() ))){ cerr << "Problem opening " << pfilename << endl; exit(1); }
  }
	
  bcf_hdr_t *hdr = bcf_hdr_dup(reader->readers[0].header);

  vector< float* > gp;

  bcf_hdr_append(hdr, "##FORMAT=<ID=GQ,Number=1,Type=Integer,Description=\"Genotype Quality\">");
  bcf_hdr_append(hdr, "##FORMAT=<ID=DS,Number=1,Type=Float,Description=\"estimated ALT dose [P(RA) + 2*P(AA)]\">");
  bcf_hdr_append(hdr, "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">");
  if(glout){
    bcf_hdr_append(hdr, "##FORMAT=<ID=GP,Number=G,Type=Float,Description=\"Estimated Genotype Probability\">");
    for(int i=0; i<M; ++i){ float *gp_arr = new float[N*3]; gp.push_back(gp_arr); }
    write_triple(Sigma, mu, lv, sigs, gl, D, gp);
  }

  htsFile *out_fh  = hts_open(out_filename.c_str(), out_type.c_str() );
  bcf_hdr_write(out_fh, hdr);

  int nline = 0;
  int nwrote = 0;
  int32_t *gt_arr= new int32_t[N*2];
  float *ds_arr= new float[N];
  float *gp_arr;
  if(glout) gp_arr = new float[N*3];
	
  int ns = 0;
  int np = 0;
  int32_t *gq_arr = new int32_t[N];//FORMAT/GQ this is phred scale probablity the most likely genotype is wrong (good for filtering)
  while(bcf_sr_next_line (reader)) { 
		
    bool count = true;
    if( use_panel ){ count = (bcf_sr_has_line(reader,0) && bcf_sr_has_line(reader,1)); }
    if( count ){	
      line =  bcf_sr_get_line(reader, 0); 

      if(line->n_allele == 2){
				
	  for(int i=0; i<N; ++i){ 
							
		  if(D(nline,i) <= bias){	
			gt_arr[2*i] = bcf_gt_unphased(0); gt_arr[2*i+1] = bcf_gt_unphased(0);
		  } 
		  if(D(nline,i) > bias && D(nline,i) <= 2.0 - bias){
			gt_arr[2*i] = bcf_gt_unphased(0); gt_arr[2*i+1] = bcf_gt_unphased(1);
		  }
		  if(D(nline,i) > 2.0 - bias){
			gt_arr[2*i] = bcf_gt_unphased(1); gt_arr[2*i+1] = bcf_gt_unphased(1);
		  }							
						
		  ds_arr[i] = D(nline,i);
		  if( glout ){
			gp_arr[3*i] = gp[nline][3*i];
			gp_arr[3*i+1] = gp[nline][3*i+1];
			gp_arr[3*i+2] = gp[nline][3*i+2];
			float tmp_prob = gp[nline][3*i + bcf_gt_allele(gt_arr[2*i]) + bcf_gt_allele(gt_arr[2*i+1])];
			if(tmp_prob<0){ //avoids ridiculous GQ values and -0 issues
				gq_arr[i] = (int32_t)(-10*log10(1 - pow(10,tmp_prob)));
			} else { 	      
				gq_arr[i] = 100;
			}
		  }	
	  } //end i
				 

	bcf_update_genotypes(hdr, line, (void*)gt_arr, 2*N);
	bcf_update_format_float(hdr,line,"DS",ds_arr, N);
	if( glout ) {
	  bcf_update_format_float(hdr,line,"GP",(void*)gp_arr, 3*N);
	  bcf_update_format_int32(hdr,line,"GQ",(void*)gq_arr, N);
	}
	bcf_unpack(line, BCF_UN_ALL);
	if(nline >= min_idx && nline < max_idx){ ++nwrote; bcf_write(out_fh, hdr, line); }

	++nline;
      } //n_alleles
    }
		
    if( use_panel ){ 
      if( bcf_sr_has_line(reader,1) && !bcf_sr_has_line(reader,0) ){ ++nline; }
    }	
  }	
  cerr << "wrote " << nwrote << " records" << endl;

  while(!gl.empty()) delete [] gl.back(), gl.pop_back();
  if(glout){
    while(!gp.empty()) delete [] gp.back(), gp.pop_back();	
    delete [] gp_arr;
  }
  bcf_sr_destroy(reader);
  hts_close(out_fh);
  bcf_hdr_destroy(hdr);
  
  delete [] gt_arr;
  delete [] ds_arr;
	
	
  return 0;
}


